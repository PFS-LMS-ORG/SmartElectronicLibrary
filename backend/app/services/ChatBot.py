# -*- coding: utf-8 -*-
"""pfsChatBotFinal.ipynb

Automatically generated by Colab.
"""

import os
import uuid
import logging
from flask_sqlalchemy import SQLAlchemy
from langchain.schema import Document
from langchain.vectorstores import FAISS
from langchain.embeddings import HuggingFaceEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_core.tools import tool
from langchain_core.messages import SystemMessage, AIMessage, HumanMessage
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import MessagesState
from langgraph.prebuilt import ToolNode, tools_condition
from langchain.chat_models import init_chat_model
from pydantic import BaseModel, Field
from typing import List, Optional

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Pydantic models for structured output
class BookRecommendation(BaseModel):
    book_id: int = Field(description="Unique ID of the book")
    title: str = Field(description="Title of the recommended book")
    author: str = Field(description="Author of the book")
    category: str = Field(description="Category of the book")
    description: str = Field(description="Description of the book")
    summary: str = Field(description="Summary of the book")
    rating: float = Field(description="Rating of the book")
    borrow_count: int = Field(description="Number of times the book has been borrowed")
    total_books: int = Field(description="Total number of copies")
    available_books: int = Field(description="Number of available copies")
    featured_book: bool = Field(description="Whether the book is featured")
    cover_url: Optional[str] = Field(default=None, description="URL of the book cover")

class ChatResponse(BaseModel):
    answer: str = Field(description="The chatbot's response to the user's query")
    follow_up_question: str = Field(description="A question to continue the conversation")
    recommended_books: Optional[List[BookRecommendation]] = Field(
        default=None,
        description="List of recommended books based on the query"
    )

class ChatBotTools:
    def __init__(self, app, vector_store, update_book_callback):
        self.app = app
        self.vector_store = vector_store
        self.update_book_callback = update_book_callback

    def _book_to_dict(self, book):
        """Convert a SQLAlchemy Book to a dictionary."""
        return {
            "book_id": book.id,
            "title": book.title or "Unknown",
            "author": book.author or "Unknown",
            "category": book.category or "Unknown",
            "description": book.description or "No description",
            "summary": book.summary or "No summary",
            "rating": float(book.rating or 0.0),
            "borrow_count": int(book.borrow_count or 0),
            "total_books": int(book.total_books or 0),
            "available_books": int(book.available_books or 0),
            "featured_book": bool(book.featured_book or False),
            "cover_url": book.cover_url or None
        }

    @tool(response_format="content_and_artifact")
    def retrieve(self, query: str):
        """Retrieve books semantically similar to the query using the vector store."""
        retrieved_docs = self.vector_store.similarity_search(query, k=3)
        books = []
        for doc in retrieved_docs:
            book_info = {
                "book_id": int(doc.metadata.get("id", 0)),
                "title": "Unknown",
                "author": "Unknown",
                "category": "Unknown",
                "description": "No description",
                "summary": "No summary",
                "rating": 0.0,
                "borrow_count": 0,
                "total_books": 0,
                "available_books": 0,
                "featured_book": False,
                "cover_url": None
            }
            lines = doc.page_content.split("\n")
            for line in lines:
                line = line.strip()
                if line.startswith("Title: "):
                    book_info["title"] = line.replace("Title: ", "").strip()
                elif line.startswith("Author: "):
                    book_info["author"] = line.replace("Author: ", "").strip()
                elif line.startswith("Category: "):
                    book_info["category"] = line.replace("Category: ", "").strip()
                elif line.startswith("Description: "):
                    book_info["description"] = line.replace("Description: ", "").strip()
                elif line.startswith("Summary: "):
                    book_info["summary"] = line.replace("Summary: ", "").strip()
                elif line.startswith("Rating: "):
                    book_info["rating"] = float(line.replace("Rating: ", "").strip())
                elif line.startswith("Borrow Count: "):
                    book_info["borrow_count"] = int(line.replace("Borrow Count: ", "").strip())
                elif line.startswith("Total Books: "):
                    book_info["total_books"] = int(line.replace("Total Books: ", "").strip())
                elif line.startswith("Available Books: "):
                    book_info["available_books"] = int(line.replace("Available Books: ", "").strip())
                elif line.startswith("Featured Book: "):
                    book_info["featured_book"] = line.replace("Featured Book: ", "").strip().lower() == "true"
                elif line.startswith("Cover URL: "):
                    book_info["cover_url"] = line.replace("Cover URL: ", "").strip() or None
            books.append(book_info)
        serialized = "\n\n".join(
            (f"Title: {doc.metadata['title']}\nContent: {doc.page_content}")
            for doc in retrieved_docs
        )
        return serialized, books

    @tool
    def get_all_categories(self):
        """Retrieve all unique book categories from the database."""
        with self.app.app_context():
            categories = db.session.query(Book).distinct().all()
            return [category[0] for category in categories if category[0]]

    @tool
    def count_books(self, category: str = None):
        """Count the total number of books, optionally filtered by category."""
        with self.app.app_context():
            query = db.session.query(Book)
            if category:
                query = query.filter(Book.category == category)
            return query.count()

    @tool
    def filter_books(self, category: str = None, author: str = None, min_rating: float = None, min_available: int = None):
        """Filter books by category, author, minimum rating, or minimum available copies."""
        with self.app.app_context():
            query = db.session.query(Book)
            if category:
                query = query.filter(Book.category == category)
            if author:
                query = query.filter(Book.author.ilike(f"%{author}%"))
            if min_rating is not None:
                query = query.filter(Book.rating >= min_rating)
            if min_available is not None:
                query = query.filter(Book.available_books >= min_available)
            books = query.limit(3).all()
            return [self._book_to_dict(book) for book in books]

    @tool
    def check_availability(self, title: str):
        """Check if a book is available to borrow based on its title."""
        with self.app.app_context():
            book = db.session.query(Book).filter(Book.title.ilike(f"%{title}%")).first()
            if book and book.available_books > 0:
                return {
                    "book_id": book.id,
                    "title": book.title,
                    "available_books": book.available_books,
                    "status": "Available"
                }
            elif book:
                return {
                    "book_id": book.id,
                    "title": book.title,
                    "available_books": 0,
                    "status": "Not available"
                }
            return {"title": title, "status": "Book not found"}

    @tool
    def get_featured_books(self):
        """Retrieve books marked as featured."""
        with self.app.app_context():
            books = db.session.query(Book).filter(Book.featured_book == True).limit(3).all()
            return [self._book_to_dict(book) for book in books]

    @tool
    def search_by_popularity(self, category: str = None, sort_by: str = "borrow_count"):
        """Retrieve books sorted by popularity (borrow_count or rating), optionally filtered by category."""
        with self.app.app_context():
            query = db.session.query(Book)
            if category:
                query = query.filter(Book.category == category)
            if sort_by == "borrow_count":
                query = query.order_by(Book.borrow_count.desc())
            elif sort_by == "rating":
                query = query.order_by(Book.rating.desc())
            books = query.limit(3).all()
            return [self._book_to_dict(book) for book in books]

    @tool
    def borrow_book(self, title: str):
        """Mark a book as borrowed if available (decrement available_books, increment borrow_count)."""
        with self.app.app_context():
            book = db.session.query(Book).filter(Book.title.ilike(f"%{title}%")).first()
            if not book:
                return {"status": "Book not found"}
            if book.available_books <= 0:
                return {"status": "Book not available"}
            book.available_books -= 1
            book.borrow_count += 1
            db.session.commit()
            self.update_book_callback(book.id)
            return {"status": "Book borrowed successfully", "book_id": book.id, "title": book.title}

    @tool
    def reserve_book(self, title: str):
        """Reserve a book if it is not available."""
        with self.app.app_context():
            book = db.session.query(Book).filter(Book.title.ilike(f"%{title}%")).first()
            if not book:
                return {"status": "Book not found"}
            if book.available_books > 0:
                return {"status": "Book is currently available, no need to reserve"}
            reservation = Reservation(book_id=book.id)
            db.session.add(reservation)
            db.session.commit()
            return {"status": "Book reserved successfully", "book_id": book.id, "title": book.title}

    @tool
    def get_book_details(self, title: str):
        """Retrieve full details of a specific book by title."""
        with self.app.app_context():
            book = db.session.query(Book).filter(Book.title.ilike(f"%{title}%")).first()
            if book:
                return self._book_to_dict(book)
            return {"status": "Book not found"}

    @tool
    def hybrid_search(self, query: str, category: str = None):
        """Combine semantic search with database filtering by category."""
        retrieved_docs = self.vector_store.similarity_search(query, k=10)
        titles = [doc.metadata["title"] for doc in retrieved_docs]
        with self.app.app_context():
            query = db.session.query(Book).filter(Book.title.in_(titles))
            if category:
                query = query.filter(Book.category == category)
            books = query.limit(3).all()
            return [self._book_to_dict(book) for book in books]

    def get_tools(self):
        """Return the list of tools."""
        return [
            self.retrieve, self.get_all_categories, self.count_books, self.filter_books,
            self.check_availability, self.get_featured_books, self.search_by_popularity,
            self.borrow_book, self.reserve_book, self.get_book_details, self.hybrid_search
        ]

class ChatBot:
    private_instance = None
    _initialized = False

    def __new__(cls, app=None):
        if cls.private_instance is None:
            cls.private_instance = super(ChatBot, cls).__new__(cls)
        return cls.private_instance

    def __init__(self, app=None):
        if self._initialized:
            return
        self.app = app
        self.llm = init_chat_model("gpt-4o-mini", model_provider="openai")
        self.embeddings = HuggingFaceEmbeddings(model_name="all-MiniLM-L6-v2")
        self.vector_store = self.load_books_from_db()
        self.tools = ChatBotTools(self.app, self.vector_store, self.update_book_in_vector_store)
        self.graph = self.create_graph()
        self._initialized = True

    def book_to_document(self, book):
        """Convert a SQLAlchemy Book row to a LangChain Document."""
        content = f"""
        Title: {book.title or 'Unknown'}
        Author: {book.author or 'Unknown'}
        Category: {book.category or 'Unknown'}
        Description: {book.description or 'No description'}
        Summary: {book.summary or 'No summary'}
        Rating: {book.rating or 0}
        Borrow Count: {book.borrow_count or 0}
        Total Books: {book.total_books or 0}
        Available Books: {book.available_books or 0}
        Featured Book: {book.featured_book or False}
        Cover URL: {book.cover_url or ''}
        """
        return Document(
            page_content=content.strip(),
            metadata={"title": book.title or "Unknown", "id": str(book.id)}
        )

    def add_book_to_vector_store(self, book_id: int):
        """Add a book to the vector store by ID."""
        with self.app.app_context():
            row = db.session.query(Book).get(book_id)
            if row:
                doc = self.book_to_document(row)
                self.vector_store.add_documents([doc])
                logger.info(f"Added book {book_id} to vector store.")

    def remove_book_from_vector_store(self, book_id: int):
        """Remove a book from the vector store by ID."""
        self.vector_store.delete([str(book_id)])
        logger.info(f"Removed book {book_id} from vector store.")

    def update_book_in_vector_store(self, book_id: int):
        """Update a book in the vector store by ID."""
        with self.app.app_context():
            row = db.session.query(Book).get(book_id)
            if row:
                self.vector_store.delete([str(book_id)])
                doc = self.book_to_document(row)
                self.vector_store.add_documents([doc])
                logger.info(f"Updated book {book_id} in vector store.")

    def load_books_from_db(self):
        """Load books from the database into the FAISS vector store."""
        cache_path = "./books_vectorstore"
        cache_index = f"{cache_path}/index.faiss"
        cache_metadata = f"{cache_path}/index.pkl"

        if os.path.exists(cache_index) and os.path.exists(cache_metadata):
            try:
                logger.info("Loading cached FAISS vector store...")
                vector_store = FAISS.load_local(
                    folder_path=cache_path,
                    embeddings=self.embeddings,
                    allow_dangerous_deserialization=True
                )
                logger.info("Cached vector store loaded successfully.")
                return vector_store
            except Exception as e:
                logger.error(f"Failed to load cached vector store: {e}")

        logger.info("Building new FAISS vector store from database...")
        with self.app.app_context():
            try:
                books = db.session.query(Book).all()
            except Exception as e:
                logger.error(f"Failed to query books from database: {e}")
                return FAISS.from_documents([], embedding=self.embeddings)

            docs = []
            for book in books:
                doc = self.book_to_document(book)
                docs.append(doc)

        splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
        chunks = splitter.split_documents(docs)
        vector_store = FAISS.from_documents(chunks, embedding=self.embeddings)

        try:
            os.makedirs(cache_path, exist_ok=True)
            vector_store.save_local(cache_path)
            logger.info(f"Vector store cached to {cache_path}.")
        except Exception as e:
            logger.error(f"Failed to cache vector store: {e}")

        return vector_store

    def create_graph(self):
        def query_or_respond(state: MessagesState):
            llm_with_tools = self.llm.bind_tools(self.tools.get_tools())
            response = llm_with_tools.invoke(state["messages"])
            return {"messages": [response]}

        def generate(state: MessagesState):
            try:
                tool_messages = [m for m in state["messages"] if m.type == "tool"]
                docs_content = "\n\n".join(msg.content for msg in tool_messages if hasattr(msg, "content"))

                system_message = SystemMessage(
                    content=(
                        "You are a library assistant. Answer the user's query using the tool outputs and conversation history. "
                        "Keep the answer short and avoid mentioning book recommendations or cover URLs in it. "
                        "In the structured output, include up to 3 books from the tool outputs in recommended_books "
                        "(with book_id, title, author, category, description, summary, rating, borrow_count, total_books, "
                        "available_books, featured_book, cover_url). If no books are relevant, set recommended_books to null. "
                        "Generate a follow-up question that is relevant to the user's query or their previous responses "
                        "(e.g., if they say 'yes' to a follow-up question, suggest related books or topics). "
                        "Use the conversation history to make the response and follow-up question context-aware.\n\n"
                        f"Tool Outputs:\n{docs_content}"
                    )
                )

                convo = [
                    msg for msg in state["messages"]
                    if msg.type in ("human", "system") or (msg.type == "ai" and not msg.tool_calls)
                ]

                prompt = [system_message] + convo
                structured_llm = self.llm.with_structured_output(ChatResponse)
                response = structured_llm.invoke(prompt)

                logger.info(f"Recommended books: {response.recommended_books}")
                logger.info(f"Follow-up question: {response.follow_up_question}")

                return {
                    "messages": [AIMessage(content=response.answer, additional_kwargs={
                        "follow_up_question": response.follow_up_question,
                        "recommended_books": response.recommended_books
                    })]
                }
            except Exception as e:
                logger.error(f"Error in generate: {e}")
                return {
                    "messages": [AIMessage(content="Sorry, I couldn't process your request.")]
                }

        builder = StateGraph(MessagesState)
        builder.add_node("query_or_respond", query_or_respond)
        builder.add_node("tools", ToolNode(self.tools.get_tools()))
        builder.add_node("generate", generate)
        builder.set_entry_point("query_or_respond")
        builder.add_conditional_edges("query_or_respond", tools_condition, {END: END, "tools": "tools"})
        builder.add_edge("tools", "generate")
        builder.add_edge("generate", END)

        return builder.compile(checkpointer=MemorySaver())

    def chat_with_user(self, user_input: str, thread_id: str) -> ChatResponse:
        config = {"configurable": {"thread_id": thread_id}}
        message = {"messages": [HumanMessage(content=user_input)]}

        final_response = None

        for step in self.graph.stream(message, stream_mode="values", config=config):
            last_message = step["messages"][-1]
            if last_message.type == "ai":
                recommended_books = last_message.additional_kwargs.get("recommended_books", None)
                if recommended_books and not isinstance(recommended_books[0], BookRecommendation):
                    recommended_books = [BookRecommendation(**book) for book in recommended_books]
                final_response = ChatResponse(
                    answer=last_message.content,
                    follow_up_question=last_message.additional_kwargs.get("follow_up_question", ""),
                    recommended_books=recommended_books
                )

        if not final_response:
            final_response = ChatResponse(
                answer="Sorry, I couldn't process your request.",
                follow_up_question="Can I help you with another query?",
                recommended_books=None
            )

        return final_response.model_dump_json(indent=2)
