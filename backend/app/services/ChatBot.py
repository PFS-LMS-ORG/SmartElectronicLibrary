# -*- coding: utf-8 -*-
"""pfsChatBotFinal.ipynb

Automatically generated by Colab.
"""

import ast
import os
import uuid
import logging
from flask_jwt_extended import get_jwt_identity
from flask_sqlalchemy import SQLAlchemy
from langchain.schema import Document
from langchain_community.vectorstores import FAISS
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_core.tools import tool
from langchain_core.messages import SystemMessage, AIMessage, HumanMessage
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import MessagesState
from langgraph.prebuilt import ToolNode, tools_condition
from langchain.chat_models import init_chat_model
from pydantic import BaseModel, Field
from typing import List, Optional, Dict

import pydantic
from app.model.Book import Book
from app.model.Author import Author
from app.model.Article import Article
from app.model.Category import Category
from app.model.ArticleAuthor import ArticleAuthor
from app.model.ArticleMeta import ArticleMeta
from app.services.RentalRequestService import RentalRequestService
from app.model.association_tables import book_author_association
from app.model.association_tables import book_category_association
from app.db import db
from datetime import datetime

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Pydantic models for structured output
class BookRecommendation(BaseModel):
    book_id: int = Field(description="Unique ID of the book")
    title: str = Field(description="Title of the recommended book")
    authors: List[str] = Field(description="Authors of the book")
    categories: List[str] = Field(description="Categories of the book")
    description: str = Field(description="Description of the book")
    summary: str = Field(description="Summary of the book")
    rating: float = Field(description="Rating of the book")
    borrow_count: int = Field(description="Number of times the book has been borrowed")
    total_books: int = Field(description="Total number of copies")
    available_books: int = Field(description="Number of available copies")
    featured_book: bool = Field(description="Whether the book is featured")
    cover_url: Optional[str] = Field(default=None, description="URL of the book cover")


class AuthorInfo(BaseModel):
    name: str
    avatarUrl: Optional[str]

    class Config:
        extra = "forbid"

class ArticleMetaInfo(BaseModel):
    readTime: int
    views: int
    likes: int
    bookmarks: int

    class Config:
        extra = "forbid"

class ArticleRecommendation(BaseModel):
    article_id: int = Field(description="Unique ID of the article")
    title: str = Field(description="Title of the article")
    category: str = Field(description="Category of the article")
    author: AuthorInfo = Field(description="Author information (name and avatar URL)")
    summary: str = Field(description="Summary of the article")
    pdf_url: str = Field(description="URL of the article PDF")
    tags: List[str] = Field(description="Tags associated with the article")
    created_at: str = Field(description="Creation date of the article in ISO format")
    updated_at: Optional[str] = Field(description="Last update date of the article in ISO format")
    cover_image_url: Optional[str] = Field(description="URL of the article cover image")
    meta: ArticleMetaInfo = Field(description="Metadata including read time, views, likes, and bookmarks")

    class Config:
        extra = "forbid"


class ChatResponse(BaseModel):
    answer: str = Field(description="The chatbot's response to the user's query")
    follow_up_question: str = Field(description="A question to continue the conversation")
    recommended_books: Optional[List[BookRecommendation]] = Field(
        default=None,
        description="List of recommended books based on the query"
    )
    recommended_articles: Optional[List[ArticleRecommendation]] = Field(
        default=None,
        description="List of recommended articles based on the query"
    )

class ChatBot:
    private_instance = None
    _initialized = False

    def __new__(cls, app=None):
        if cls.private_instance is None:
            cls.private_instance = super(ChatBot, cls).__new__(cls)
        return cls.private_instance

    def __init__(self, app=None):
        if self._initialized:
            return
        self.app = app
        self.llm = init_chat_model("gpt-4o-mini", model_provider="openai")
        self.embeddings = HuggingFaceEmbeddings(model_name="all-MiniLM-L6-v2")
        self.vector_store = self.load_items_from_db()
        self.update_book_callback = self.update_book_in_vector_store
        self.graph = self.create_graph()
        self._initialized = True

    def _book_to_dict(self, book):
        """Convert a SQLAlchemy Book to a dictionary."""
        return {
            "book_id": book.id,
            "title": book.title or "Unknown",
            "authors": [author.name for author in book.authors] or ["Unknown"],
            "categories": [category.name for category in book.categories] or ["Unknown"],
            "description": book.description or "No description",
            "summary": book.summary or "No summary",
            "rating": float(book.rating or 0.0),
            "borrow_count": int(book.borrow_count or 0),
            "total_books": int(book.total_books or 0),
            "available_books": int(book.available_books or 0),
            "featured_book": bool(book.featured_book or False),
            "cover_url": book.cover_url or None
        }

    def _article_to_dict(self, article):
        """Convert a SQLAlchemy Article to a dictionary."""
        try:
            return {
                "article_id": article.id,
                "title": article.title or "Unknown",
                "category": article.category or "Unknown",
                "author": {
                    "name": article.author.name if hasattr(article, 'author') and article.author else "Unknown",
                    "avatarUrl": article.author.avatar_url if hasattr(article, 'author') and article.author and hasattr(article.author, 'avatar_url') else None
                },
                "summary": article.summary or "No summary",
                "pdf_url": article.pdf_url or "",
                "tags": article.tags or [],
                "created_at": article.created_at.isoformat() + 'Z' if article.created_at else "",
                # Explicitly add the missing required fields
                "updated_at": article.updated_at.isoformat() + 'Z' if hasattr(article, 'updated_at') and article.updated_at else None,
                "cover_image_url": article.cover_image_url if hasattr(article, 'cover_image_url') else None,
                "meta": {
                    "readTime": article.meta.read_time if hasattr(article, 'meta') and hasattr(article.meta, 'read_time') else 5,
                    "views": article.meta.views if hasattr(article, 'meta') and hasattr(article.meta, 'views') else 0,
                    "likes": article.meta.likes_count if hasattr(article, 'meta') and hasattr(article.meta, 'likes_count') else 0,
                    "bookmarks": article.meta.bookmarks_count if hasattr(article, 'meta') and hasattr(article.meta, 'bookmarks_count') else 0
                }
            }
        except Exception as e:
            logger.error(f"Error in _article_to_dict: {e}", exc_info=True)
            # Return a minimal valid dictionary that meets all Pydantic requirements
            return {
                "article_id": getattr(article, 'id', 0),
                "title": getattr(article, 'title', "Unknown"),
                "category": "Unknown",
                "author": {"name": "Unknown", "avatarUrl": None},
                "summary": "No summary available",
                "pdf_url": "",
                "tags": [],
                "created_at": "",
                "updated_at": None,  # Required field
                "cover_image_url": None,  # Required field
                "meta": {"readTime": 5, "views": 0, "likes": 0, "bookmarks": 0}
            }
    
    
    def get_tools(self):
        """Return the list of tools."""
        
        @tool(response_format="content_and_artifact")
        def retrieve(query: str):
            """Retrieve books and articles semantically similar to the query using the vector store."""
            try:
                # Normalize and clean the query
                clean_query = query.strip().lower()
                
                # Get documents from vector store with increased k for better coverage
                retrieved_docs = self.vector_store.similarity_search(clean_query, k=12)
                
                # Handle case when no results are found
                if not retrieved_docs:
                    logger.info(f"No results found for query: {query}")
                    return "No matching books or articles found in our database.", {"books": [], "articles": []}
                    
                books = []
                articles = []
                
                # Process each retrieved document
                for doc in retrieved_docs:
                    try:
                        # Extract metadata safely with defaults
                        item_type = doc.metadata.get("type", "unknown")
                        item_id = doc.metadata.get("id", "0")
                        
                        # Parse ID correctly based on format (handles both formats: "123" and "book_123")
                        try:
                            if isinstance(item_id, str):
                                if item_id.startswith("book_"):
                                    item_id = int(item_id.replace("book_", ""))
                                elif item_id.startswith("article_"):
                                    item_id = int(item_id.replace("article_", ""))
                                else:
                                    item_id = int(item_id)
                        except ValueError:
                            logger.warning(f"Could not convert ID to integer: {item_id}, using as is")
                        
                        # Initialize with mandatory fields
                        if item_type == "book":
                            item_info = {
                                "book_id": item_id,
                                "title": "Unknown",
                                "authors": ["Unknown"],
                                "categories": ["Uncategorized"],
                                "description": "No description available",
                                "summary": "No summary available",
                                "rating": 0.0,
                                "borrow_count": 0,
                                "total_books": 0,
                                "available_books": 0,
                                "featured_book": False,
                                "cover_url": None
                            }
                        elif item_type == "article":
                            item_info = {
                                "article_id": item_id,
                                "title": "Unknown",
                                "category": "Uncategorized",
                                "author": {"name": "Unknown", "avatarUrl": None},
                                "summary": "No summary available",
                                "pdf_url": "",
                                "tags": [],
                                "created_at": "",
                                "updated_at": None,
                                "cover_image_url": None,
                                "meta": {
                                    "readTime": 5,
                                    "views": 0,
                                    "likes": 0,
                                    "bookmarks": 0
                                }
                            }
                        else:
                            # Skip items with unknown type
                            logger.warning(f"Unknown item type: {item_type}, skipping document")
                            continue
                        
                        # Parse the document content line by line
                        lines = doc.page_content.split("\n")
                        for line in lines:
                            line = line.strip()
                            if not line:
                                continue
                                
                            # Process common fields
                            if line.startswith("Title: "):
                                item_info["title"] = line.replace("Title: ", "").strip() or "Unknown"
                            elif line.startswith("Summary: "):
                                item_info["summary"] = line.replace("Summary: ", "").strip() or "No summary available"
                            
                            # Process book-specific fields
                            if item_type == "book":
                                if line.startswith("Authors: "):
                                    authors_text = line.replace("Authors: ", "").strip()
                                    if authors_text:
                                        item_info["authors"] = [a.strip() for a in authors_text.split(",")]
                                    else:
                                        item_info["authors"] = ["Unknown"]
                                        
                                elif line.startswith("Categories: "):
                                    categories_text = line.replace("Categories: ", "").strip()
                                    if categories_text:
                                        item_info["categories"] = [c.strip() for c in categories_text.split(",")]
                                    else:
                                        item_info["categories"] = ["Uncategorized"]
                                        
                                elif line.startswith("Description: "):
                                    item_info["description"] = line.replace("Description: ", "").strip() or "No description"
                                    
                                elif line.startswith("Rating: "):
                                    try:
                                        item_info["rating"] = float(line.replace("Rating: ", "").strip())
                                    except (ValueError, TypeError):
                                        item_info["rating"] = 0.0
                                        
                                elif line.startswith("Borrow Count: "):
                                    try:
                                        item_info["borrow_count"] = int(line.replace("Borrow Count: ", "").strip())
                                    except (ValueError, TypeError):
                                        item_info["borrow_count"] = 0
                                        
                                elif line.startswith("Total Books: "):
                                    try:
                                        item_info["total_books"] = int(line.replace("Total Books: ", "").strip())
                                    except (ValueError, TypeError):
                                        item_info["total_books"] = 0
                                        
                                elif line.startswith("Available Books: "):
                                    try:
                                        item_info["available_books"] = int(line.replace("Available Books: ", "").strip())
                                    except (ValueError, TypeError):
                                        item_info["available_books"] = 0
                                        
                                elif line.startswith("Featured Book: "):
                                    item_info["featured_book"] = line.replace("Featured Book: ", "").strip().lower() == "true"
                                    
                                elif line.startswith("Cover URL: "):
                                    url = line.replace("Cover URL: ", "").strip()
                                    item_info["cover_url"] = url if url else None
                            
                            # Process article-specific fields
                            elif item_type == "article":
                                if line.startswith("Author: "):
                                    item_info["author"]["name"] = line.replace("Author: ", "").strip() or "Unknown"
                                    
                                elif line.startswith("Category: "):
                                    item_info["category"] = line.replace("Category: ", "").strip() or "Uncategorized"
                                    
                                elif line.startswith("PDF URL: "):
                                    item_info["pdf_url"] = line.replace("PDF URL: ", "").strip() or ""
                                    
                                elif line.startswith("Tags: "):
                                    tags_text = line.replace("Tags: ", "").strip()
                                    if tags_text:
                                        # Safely evaluate tags - they might be stored as a Python list representation
                                        try:
                                            tags = ast.literal_eval(tags_text)
                                            if isinstance(tags, list):
                                                item_info["tags"] = tags
                                            else:
                                                item_info["tags"] = []
                                        except (SyntaxError, ValueError):
                                            # If not a valid Python expression, try to split by comma
                                            item_info["tags"] = [t.strip() for t in tags_text.split(",")]
                                    else:
                                        item_info["tags"] = []
                                        
                                elif line.startswith("Created At: "):
                                    item_info["created_at"] = line.replace("Created At: ", "").strip() or ""
                                    
                                elif line.startswith("Updated At: "):
                                    updated_at = line.replace("Updated At: ", "").strip()
                                    item_info["updated_at"] = updated_at if updated_at else None
                                    
                                elif line.startswith("Cover Image URL: "):
                                    cover_url = line.replace("Cover Image URL: ", "").strip()
                                    item_info["cover_image_url"] = cover_url if cover_url else None
                                    
                                elif line.startswith("Meta: "):
                                    meta_text = line.replace("Meta: ", "").strip()
                                    if meta_text:
                                        try:
                                            meta = ast.literal_eval(meta_text)
                                            if isinstance(meta, dict):
                                                # Ensure all required fields exist
                                                meta_fields = {
                                                    "readTime": meta.get("readTime", 5),
                                                    "views": meta.get("views", 0),
                                                    "likes": meta.get("likes", 0),
                                                    "bookmarks": meta.get("bookmarks", 0)
                                                }
                                                item_info["meta"] = meta_fields
                                        except (SyntaxError, ValueError):
                                            logger.warning(f"Could not parse meta information: {meta_text}")
                        
                        # Add the item to the appropriate list if it has the minimum required fields
                        if item_type == "book" and item_info["title"] != "Unknown":
                            books.append(item_info)
                            logger.debug(f"Added book: {item_info['title']} (ID: {item_info['book_id']})")
                        elif item_type == "article" and item_info["title"] != "Unknown":
                            articles.append(item_info)
                            logger.debug(f"Added article: {item_info['title']} (ID: {item_info['article_id']})")
                        else:
                            logger.warning(f"Skipping item with insufficient data: {item_info}")
                            
                    except Exception as e:
                        logger.error(f"Error processing document: {e}", exc_info=True)
                        continue
                
                # Create a readable serialized representation of the results
                serialized = "\n\n".join(
                    (f"Title: {doc.metadata.get('title', 'Unknown')}\n"
                    f"Type: {doc.metadata.get('type', 'unknown')}\n"
                    f"ID: {doc.metadata.get('id', 'unknown')}\n"
                    f"Content: {doc.page_content}")
                    for doc in retrieved_docs
                )
                
                logger.info(f"Retrieved {len(books)} books and {len(articles)} articles for query: {query}")
                
                return serialized, {"books": books, "articles": articles}
                
            except Exception as e:
                logger.error(f"Error in retrieve function: {e}", exc_info=True)
                return (
                    f"Error retrieving content from the database. Please try a different search.",
                    {"books": [], "articles": []}
                )


        @tool
        def get_all_categories():
            """Retrieve all unique book and article categories from the database."""
            with self.app.app_context():
                book_categories = db.session.query(Category.name).join(book_category_association).join(Book).distinct().all()
                article_categories = db.session.query(Article.category).distinct().all()
                categories = set([cat[0] for cat in book_categories + article_categories if cat[0]])
                return list(categories)

        @tool
        def count_books(category: str = None):
            """Count the total number of books, optionally filtered by category."""
            with self.app.app_context():
                query = db.session.query(Book)
                if category:
                    query = query.join(book_category_association).join(Category).filter(Category.name == category)
                return query.count()

        @tool
        def filter_books(category: str = None, author: str = None, min_rating: float = None, min_available: int = None):
            """Filter books by category, author, minimum rating, or minimum available copies."""
            with self.app.app_context():
                query = db.session.query(Book)
                if category:
                    query = query.join(book_category_association).join(Category).filter(Category.name == category)
                if author:
                    query = query.join(book_author_association).join(Author).filter(Author.name.ilike(f"%{author}%"))
                if min_rating is not None:
                    query = query.filter(Book.rating >= min_rating)
                if min_available is not None:
                    query = query.filter(Book.available_books >= min_available)
                books = query.limit(3).all()
                return [self._book_to_dict(book) for book in books]

        @tool
        def check_availability(title: str):
            """Check if a book is available to borrow based on its title."""
            with self.app.app_context():
                book = db.session.query(Book).filter(Book.title.ilike(f"%{title}%")).first()
                if book and book.available_books > 0:
                    return {
                        "book_id": book.id,
                        "title": book.title,
                        "available_books": book.available_books,
                        "status": "Available"
                    }
                elif book:
                    return {
                        "book_id": book.id,
                        "title": book.title,
                        "available_books": 0,
                        "status": "Not available"
                    }
                return {"title": title, "status": "Book not found"}

        @tool
        def get_featured_books():
            """Retrieve books marked as featured."""
            with self.app.app_context():
                books = db.session.query(Book).filter(Book.featured_book == True).limit(3).all()
                return [self._book_to_dict(book) for book in books]

        @tool
        def search_by_popularity(category: str = None, sort_by: str = "borrow_count"):
            """Retrieve books sorted by popularity (borrow_count or rating), optionally filtered by category."""
            with self.app.app_context():
                query = db.session.query(Book)
                if category:
                    query = query.join(book_category_association).join(Category).filter(Category.name == category)
                if sort_by == "borrow_count":
                    query = query.order_by(Book.borrow_count.desc())
                elif sort_by == "rating":
                    query = query.order_by(Book.rating.desc())
                books = query.limit(3).all()
                return [self ._book_to_dict(book) for book in books]

        @tool
        def borrow_book(title: str):
            """Mark a book as borrowed if available (decrement available_books, increment borrow_count)."""
            with self.app.app_context():
                book = db.session.query(Book).filter(Book.title.ilike(f"%{title}%")).first()
                if not book:
                    return {"status": "Book not found"}
                if book.available_books <= 0:
                    return {"status": "Book not available"}
                
                # Create a rental Request
                user_id = get_jwt_identity()
                if not user_id:
                    return {"status": "User not authenticated"}
                
                rental_request = RentalRequestService.create_request(
                    user_id=user_id,
                    book_id=book.id
                )
                
                if not rental_request:
                    return {"status": "Failed to create rental request"}
                
                self.update_book_callback(book.id)
                
                return {
                    "status": "Rental request created successfully",
                    "rental_request_id": rental_request.id,
                    "book_id": book.id,
                    "title": book.title
                }

        @tool
        def get_book_details(title: str):
            """Retrieve full details of a specific book by title."""
            with self.app.app_context():
                book = db.session.query(Book).filter(Book.title.ilike(f"%{title}%")).first()
                if book:
                    return self._book_to_dict(book)
                return {"status": "Book not found"}

        @tool
        def hybrid_search(query: str, category: str = None):
            """Combine semantic search with database filtering by category for books and articles."""
            retrieved_docs = self.vector_store.similarity_search(query, k=10)
            titles = [doc.metadata["title"] for doc in retrieved_docs]
            with self.app.app_context():
                books = db.session.query(Book).filter(Book.title.in_(titles)).limit(3).all()
                articles = db.session.query(Article).filter(Article.title.in_(titles)).limit(3).all()
                results = {
                    "books": [self._book_to_dict(book) for book in books],
                    "articles": [self._article_to_dict(article) for article in articles]
                }
                if category:
                    results["books"] = [b for b in results["books"] if category in b["categories"]]
                    results["articles"] = [a for a in results["articles"] if a["category"] == category]
                return results

        @tool
        def get_article_details(title: str):
            """Retrieve full details of a specific article by title."""
            with self.app.app_context():
                article = db.session.query(Article).filter(Article.title.ilike(f"%{title}%")).first()
                if article:
                    return self._article_to_dict(article)
                return {"status": "Article not found"}

        @tool
        def filter_articles(category: str = None, author_name: str = None, min_read_time: int = None, min_likes: int = None):
            """Filter articles by category, author name, minimum read time, or minimum likes."""
            with self.app.app_context():
                try:
                    query = db.session.query(Article)
                    
                    # Apply filters only if provided
                    if category:
                        query = query.filter(Article.category == category)
                    if author_name:
                        query = query.join(ArticleAuthor).filter(ArticleAuthor.name.ilike(f"%{author_name}%"))
                    if min_read_time is not None:
                        query = query.join(ArticleMeta).filter(ArticleMeta.read_time >= min_read_time)
                    if min_likes is not None:
                        query = query.join(ArticleMeta).filter(ArticleMeta.likes_count >= min_likes)
                        
                    # Get results
                    articles = query.limit(3).all()
                    
                    # If no results and filters were applied, try again with fewer filters
                    if not articles and (category or author_name or min_read_time or min_likes):
                        # Try again with no filters
                        query = db.session.query(Article)
                        articles = query.limit(3).all()
                        
                    return [self._article_to_dict(article) for article in articles]
                except Exception as e:
                    logger.error(f"Error filtering articles: {e}", exc_info=True)
                    return []


        @tool
        def search_articles(query: str = None):
            """Search for articles in the database by semantic query."""
            try:
                # First try to search by category if provided
                with self.app.app_context():
                    articles = None
                    
                    # Default to returning some articles if query is not provided
                    if not query:
                        articles = db.session.query(Article).limit(5).all()
                        if articles and len(articles) > 0:
                            logger.info(f"Found {len(articles)} articles without query")
                            return [self._article_to_dict(article) for article in articles]
                    
                    # If we reach here and have no articles or had a query, try semantic search
                    try:
                        # Semantic search for articles
                        filter_dict = {"type": "article"}
                        retrieved_docs = self.vector_store.similarity_search(
                            query if query else "interesting articles", 
                            k=10,
                            filter=filter_dict  
                        )
                        
                        if retrieved_docs:
                            logger.info(f"Found {len(retrieved_docs)} documents via semantic search")
                        
                        # Extract article IDs
                        article_ids = []
                        for doc in retrieved_docs:
                            if doc.metadata.get("type") == "article":
                                article_id = doc.metadata.get("id", "")
                                if article_id.startswith("article_"):
                                    article_id = article_id.replace("article_", "")
                                try:
                                    article_ids.append(int(article_id))
                                except ValueError:
                                    continue
                        
                        # Fetch articles from database if we have IDs
                        if article_ids:
                            articles = db.session.query(Article).filter(Article.id.in_(article_ids)).all()
                            logger.info(f"Found {len(articles)} articles by ID from semantic search")
                            return [self._article_to_dict(article) for article in articles]
                    except Exception as search_error:
                        logger.error(f"Error in semantic search: {search_error}", exc_info=True)
                    
                    # Final fallback - get some articles sorted by creation date
                    if not articles or len(articles) == 0:
                        logger.info("Falling back to most recent articles")
                        articles = db.session.query(Article).order_by(Article.created_at.desc()).limit(5).all()
                        if articles and len(articles) > 0:
                            return [self._article_to_dict(article) for article in articles]
                    
                    # If we still have nothing, return empty list
                    logger.warning("No articles found in any search method")
                    return []
                        
            except Exception as e:
                logger.error(f"Error searching articles: {e}", exc_info=True)
                return []


        @tool
        def search_articles_by_popularity(category: str = None, sort_by: str = "likes"):
            """Retrieve articles sorted by popularity (likes or views), optionally filtered by category."""
            with self.app.app_context():
                query = db.session.query(Article).join(ArticleMeta)
                if category:
                    query = query.filter(Article.category == category)
                if sort_by == "likes":
                    query = query.order_by(ArticleMeta.likes_count.desc())
                elif sort_by == "views":
                    query = query.order_by(ArticleMeta.views.desc())
                articles = query.limit(3).all()
                return [self._article_to_dict(article) for article in articles]
        
        @tool
        def debug_articles():
            """Debug tool to check if articles exist in the database and can be retrieved."""
            with self.app.app_context():
                try:
                    article_count = db.session.query(Article).count()
                    sample_articles = db.session.query(Article).limit(3).all()
                    article_categories = db.session.query(Article.category).distinct().all()
                    
                    result = {
                        "total_articles": article_count,
                        "category_count": len(article_categories),
                        "categories": [cat[0] for cat in article_categories if cat[0]],
                        "sample_articles": [
                            {
                                "id": a.id,
                                "title": a.title,
                                "category": a.category,
                                "has_author": hasattr(a, 'author') and a.author is not None,
                                "has_meta": hasattr(a, 'meta') and a.meta is not None
                            } for a in sample_articles
                        ]
                    }
                    
                    # Check vector store
                    article_docs = self.vector_store.similarity_search(
                        "article", k=5, filter={"type": "article"}
                    )
                    
                    result["article_docs_found"] = len(article_docs)
                    result["article_doc_metadata"] = [doc.metadata for doc in article_docs[:3]]
                    
                    return result
                except Exception as e:
                    logger.error(f"Debug Articles Error: {e}", exc_info=True)
                    return {"error": str(e)}
        
        
        return [
            retrieve, get_all_categories, count_books, filter_books,
            check_availability, get_featured_books, search_by_popularity,
            borrow_book, get_book_details, hybrid_search, search_articles, debug_articles,
            get_article_details, filter_articles, search_articles_by_popularity
        ]

    def item_to_document(self, item, item_type: str):
        """Convert a SQLAlchemy Book or Article to a LangChain Document."""
        if item_type == "book":
            authors = ', '.join([author.name for author in item.authors]) if hasattr(item, 'authors') and item.authors else 'Unknown'
            categories = ', '.join([category.name for category in item.categories]) if hasattr(item, 'categories') and item.categories else 'Unknown'
            
            content = f"""
            Title: {item.title or 'Unknown'}
            Authors: {authors}
            Categories: {categories}
            Description: {item.description or 'No description'}
            Summary: {item.summary or 'No summary'}
            Rating: {item.rating or 0}
            Borrow Count: {item.borrow_count or 0}
            Total Books: {item.total_books or 0}
            Available Books: {item.available_books or 0}
            Featured Book: {item.featured_book or False}
            Cover URL: {item.cover_url or ''}
            """
            metadata = {
                "title": item.title or "Unknown", 
                "id": str(item.id), 
                "type": "book",
                "authors": authors,
                "categories": categories
            }
        elif item_type == "article":
            # Handle case when article has no author
            author_name = item.author.name if hasattr(item, 'author') and item.author else 'Unknown'
            
            content = f"""
            Title: {item.title or 'Unknown'}
            Author: {author_name}
            Category: {item.category or 'Unknown'}
            Summary: {item.summary or 'No summary'}
            PDF URL: {item.pdf_url or ''}
            Tags: {item.tags or []}
            Created At: {item.created_at.isoformat() + 'Z' if item.created_at else ''}
            Updated At: {item.updated_at.isoformat() + 'Z' if item.updated_at else ''}
            Cover Image URL: {item.cover_image_url or ''}
            Meta: {item.meta.to_dict() if hasattr(item, 'meta') and item.meta else {'readTime': 5, 'views': 0, 'likes': 0, 'bookmarks': 0}}
            """
            metadata = {
                "title": item.title or "Unknown", 
                "id": str(item.id), 
                "type": "article",
                "author": author_name,
                "category": item.category or "Unknown"
            }
        else:
            raise ValueError(f"Invalid item_type: {item_type}")
            
        return Document(
            page_content=content.strip(),
            metadata=metadata
        )


    def add_book_to_vector_store(self, book_id: int):
        """Add a book to the vector store by ID."""
        with self.app.app_context():
            row = db.session.query(Book).get(book_id)
            if row:
                doc = self.item_to_document(row, "book")
                self.vector_store.add_documents([doc])
                logger.info(f"Added book {book_id} to vector store.")

    def add_article_to_vector_store(self, article_id: int):
        """Add an article to the vector store by ID."""
        with self.app.app_context():
            row = db.session.query(Article).get(article_id)
            if row:
                doc = self.item_to_document(row, "article")
                self.vector_store.add_documents([doc])
                logger.info(f"Added article {article_id} to vector store.")

    def remove_book_from_vector_store(self, book_id: int):
        """Remove a book from the vector store by ID."""
        self.vector_store.delete([f"book_{book_id}"])
        logger.info(f"Removed book {book_id} from vector store.")

    def remove_article_from_vector_store(self, article_id: int):
        """Remove an article from the vector store by ID."""
        self.vector_store.delete([f"article_{article_id}"])
        logger.info(f"Removed article {article_id} from vector store.")

    def update_book_in_vector_store(self, book_id: int):
        """Update a book in the vector store by ID."""
        with self.app.app_context():
            row = db.session.query(Book).get(book_id)
            if row:
                self.vector_store.delete([f"book_{book_id}"])
                doc = self.item_to_document(row, "book")
                self.vector_store.add_documents([doc])
                logger.info(f"Updated book {book_id} in vector store.")

    def update_article_in_vector_store(self, article_id: int):
        """Update an article in the vector store by ID."""
        with self.app.app_context():
            row = db.session.query(Article).get(article_id)
            if row:
                self.vector_store.delete([f"article_{article_id}"])
                doc = self.item_to_document(row, "article")
                self.vector_store.add_documents([doc])
                logger.info(f"Updated article {article_id} in vector store.")

    def load_items_from_db(self):
        """Load books and articles from the database into the FAISS vector store."""
        cache_path = "./items_vectorstore"
        cache_index = f"{cache_path}/index.faiss"
        cache_metadata = f"{cache_path}/index.pkl"

        if os.path.exists(cache_index) and os.path.exists(cache_metadata):
            try:
                logger.info("Loading cached FAISS vector store...")
                vector_store = FAISS.load_local(
                    folder_path=cache_path,
                    embeddings=self.embeddings,
                    allow_dangerous_deserialization=True
                )
                logger.info("Cached vector store loaded successfully.")
                return vector_store
            except Exception as e:
                logger.error(f"Failed to load cached vector store: {e}", exc_info=True)

        logger.info("Building new FAISS vector store from database...")
        with self.app.app_context():
            try:
                # Get books and articles with error handling
                try:
                    books = db.session.query(Book).limit(100).all()
                    logger.info(f"Retrieved {len(books)} books from database")
                except Exception as book_error:
                    logger.error(f"Failed to query books: {book_error}")
                    books = []
                    
                try:
                    articles = db.session.query(Article).limit(100).all()
                    logger.info(f"Retrieved {len(articles)} articles from database")
                except Exception as article_error:
                    logger.error(f"Failed to query articles: {article_error}")
                    articles = []

                # Create documents for indexing
                docs = []
                
                # Process books
                for book in books:
                    try:
                        doc = self.item_to_document(book, "book")
                        doc.metadata["id"] = f"book_{book.id}"
                        docs.append(doc)
                        logger.debug(f"Added book to index: {book.title} (ID: {book.id})")
                    except Exception as e:
                        logger.error(f"Error processing book {book.id}: {e}")
                
                # Process articles
                for article in articles:
                    try:
                        doc = self.item_to_document(article, "article")
                        doc.metadata["id"] = f"article_{article.id}"
                        docs.append(doc)
                        logger.debug(f"Added article to index: {article.title} (ID: {article.id})")
                    except Exception as e:
                        logger.error(f"Error processing article {article.id}: {e}")

                if not docs:
                    logger.warning("No documents to index! Creating a minimal vector store.")
                    return FAISS.from_texts(["Empty library database"], embedding=self.embeddings)

                # Split into chunks and create vector store
                splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
                chunks = splitter.split_documents(docs)
                vector_store = FAISS.from_documents(chunks, embedding=self.embeddings)
                
                # Log indexing stats
                book_count = sum(1 for d in docs if d.metadata.get("type") == "book")
                article_count = sum(1 for d in docs if d.metadata.get("type") == "article")
                logger.info(f"Indexed {book_count} books and {article_count} articles with {len(chunks)} total chunks")

            except Exception as e:
                logger.error(f"Failed to build vector store: {e}", exc_info=True)
                return FAISS.from_texts(["Error building library index"], embedding=self.embeddings)

        # Cache the vector store
        try:
            os.makedirs(cache_path, exist_ok=True)
            vector_store.save_local(cache_path)
            logger.info(f"Vector store cached to {cache_path}.")
        except Exception as e:
            logger.error(f"Failed to cache vector store: {e}")

        return vector_store


    def create_graph(self):
        def query_or_respond(state: MessagesState):
            llm_with_tools = self.llm.bind_tools(self.get_tools())
            response = llm_with_tools.invoke(state["messages"])
            return {"messages": [response]}

        def generate(state: MessagesState):
            try:
                tool_messages = [m for m in state["messages"] if m.type == "tool"]
        
                docs_content_list = []
                for msg in tool_messages:
                    if hasattr(msg, "content"):
                        if isinstance(msg.content, str):
                            docs_content_list.append(msg.content)
                        elif isinstance(msg.content, list):
                            # Process list content
                            if msg.content:  # Check if list is not empty
                                # Handle results from tools that return lists
                                try:
                                    # Convert list items to strings and join with newlines
                                    list_str = "\n".join([str(item) for item in msg.content])
                                    docs_content_list.append(f"List results: {list_str}")
                                except Exception as e:
                                    logger.warning(f"Error processing list content: {e}")
                                    docs_content_list.append("Unable to process list content")
                            else:
                                # Empty list - no results
                                docs_content_list.append("No results found")
                        else:
                            logger.warning(f"Non-string, non-list content found: {type(msg.content)}")
                            docs_content_list.append(f"Content of type {type(msg.content)}")
                
                docs_content = "\n\n".join(docs_content_list)
                
                # If no tool content is available, provide a fallback
                if not docs_content.strip():
                    docs_content = "No relevant information found in the database."

                
                
                system_message = SystemMessage(
                    content=(
                        "You are YOA+, a library assistant for a specific library collection. ONLY respond with information that is explicitly "
                        "present in the database search results provided below.\n\n"
                        
                        "CRITICAL INSTRUCTIONS:\n"
                        "1. NEVER invent or hallucinate books or articles - only use what's in the database results.\n"
                        "2. If no relevant items are found in the database, clearly state this fact.\n"
                        "3. EXTREMELY IMPORTANT: Keep your 'answer' field VERY CONCISE (2-3 sentences maximum) and NEVER include ANY book or article details (titles, authors, summaries) in the main answer.\n"
                        "4. Your main answer should ONLY acknowledge the user's query and indicate if you found relevant items, like: 'Here are some books about JavaScript you might find interesting.' or 'I couldn't find any articles on that topic.'\n"
                        "5. All book details must ONLY appear in the recommended_books structured field.\n"
                        "6. All article details must ONLY appear in the recommended_articles structured field.\n"
                        "7. If the user asks for something not in the database, say 'I don't have that information in our library database.'\n"
                        "8. Make follow-up questions relevant to the user's query or the recommendations provided.\n\n"
                        
                        "RESPONSE FORMAT EXAMPLE:\n"
                        "- Correct answer: 'I found some books in our collection that match your interest in machine learning.'\n"
                        "- WRONG answer: 'Here are some books: 1. \"Machine Learning Basics\" by John Smith...'\n\n"
                        
                        f"DATABASE SEARCH RESULTS:\n{docs_content}"
                    )
                )
                
                
                convo = [
                    msg for msg in state["messages"]
                    if msg.type in ("human", "system") or (msg.type == "ai" and not msg.tool_calls)
                ]

                prompt = [system_message] + convo
                
                structured_llm = self.llm.with_structured_output(ChatResponse, method="function_calling")
                try:
                    response = structured_llm.invoke(prompt)
                except pydantic.ValidationError as e:
                    # Handle validation errors specifically
                    logger.error(f"Validation error in generate: {e}")
                    # Create a valid default response
                    response = ChatResponse(
                        answer="I found some information that might interest you in our library collection.",
                        follow_up_question="Would you like to explore any specific topics?",
                        recommended_books=None,
                        recommended_articles=None
                    )
                except Exception as e:
                    # Handle other errors
                    logger.error(f"Error in structured output: {e}", exc_info=True)
                    response = ChatResponse(
                        answer="I'm sorry, I encountered an error while processing your request.",
                        follow_up_question="Could you try asking in a different way?",
                        recommended_books=None,
                        recommended_articles=None
                    )

                # Before returning, make sure all fields are properly set
                if response.recommended_books:
                    for book in response.recommended_books:
                        # Ensure all required fields are present
                        if not hasattr(book, "updated_at") or book.updated_at is None:
                            book.updated_at = None
                        if not hasattr(book, "cover_url") or book.cover_url is None:
                            book.cover_url = None
                            
                if response.recommended_articles:
                    for article in response.recommended_articles:
                        # Ensure all required fields are present
                        if not hasattr(article, "updated_at") or article.updated_at is None:
                            article.updated_at = None
                        if not hasattr(article, "cover_image_url") or article.cover_image_url is None:
                            article.cover_image_url = None
                
                logger.info(f"Recommended books: {response.recommended_books}")
                logger.info(f"Recommended articles: {response.recommended_articles}")
                logger.info(f"Follow-up question: {response.follow_up_question}")

                return {
                    "messages": [AIMessage(content=response.answer, additional_kwargs={
                        "follow_up_question": response.follow_up_question,
                        "recommended_books": response.recommended_books,
                        "recommended_articles": response.recommended_articles
                    })]
                }
                
            except Exception as e:
                logger.error(f"Error in generate: {e}", exc_info=True)
                return {
                    "messages": [AIMessage(content="I'm sorry, I encountered an error while processing your request. Please try a different question about our library collection.")]
                }
                
            except Exception as e:
                logger.error(f"Error in generate: {e}", exc_info=True)  # Include traceback
                return {
                    "messages": [AIMessage(content="I'm sorry, I encountered an error while processing your request. Please try a different question about our library collection.")]
                }



        builder = StateGraph(MessagesState)
        builder.add_node("query_or_respond", query_or_respond)
        builder.add_node("tools", ToolNode(self.get_tools()))
        builder.add_node("generate", generate)
        builder.set_entry_point("query_or_respond")
        builder.add_conditional_edges("query_or_respond", tools_condition, {END: END, "tools": "tools"})
        builder.add_edge("tools", "generate")
        builder.add_edge("generate", END)

        return builder.compile(checkpointer=MemorySaver())



    def chat_with_user(self, user_input: str, thread_id: str) -> ChatResponse:
        """Process a user message and return a response with recommendations."""
        config = {"configurable": {"thread_id": thread_id}}
        message = {"messages": [HumanMessage(content=user_input)]}

        final_response = None

        try:
            for step in self.graph.stream(message, stream_mode="values", config=config):
                last_message = step["messages"][-1]
                if last_message.type == "ai":
                    try:
                        # Extract additional kwargs safely
                        additional_kwargs = getattr(last_message, "additional_kwargs", {}) or {}
                        recommended_books = additional_kwargs.get("recommended_books", None)
                        recommended_articles = additional_kwargs.get("recommended_articles", None)
                        follow_up_question = additional_kwargs.get("follow_up_question", "Would you like recommendations on another topic?")
                        
                        # Validate and convert books
                        processed_books = None
                        if recommended_books:
                            try:
                                validated_books = []
                                for book in recommended_books:
                                    # Check if book has minimum required fields
                                    if isinstance(book, dict) and 'title' in book:
                                        # Ensure all required fields exist
                                        book_obj = {
                                            "book_id": book.get("book_id", 0),
                                            "title": book.get("title", "Unknown"),
                                            "authors": book.get("authors", ["Unknown"]),
                                            "categories": book.get("categories", ["Unknown"]),
                                            "description": book.get("description", "No description"),
                                            "summary": book.get("summary", "No summary"),
                                            "rating": float(book.get("rating", 0.0)),
                                            "borrow_count": int(book.get("borrow_count", 0)),
                                            "total_books": int(book.get("total_books", 0)),
                                            "available_books": int(book.get("available_books", 0)),
                                            "featured_book": bool(book.get("featured_book", False)),
                                            "cover_url": book.get("cover_url", None)
                                        }
                                        validated_books.append(book_obj)
                                processed_books = validated_books
                            except Exception as e:
                                logger.error(f"Error validating books: {e}", exc_info=True)
                                processed_books = None
                        
                        # Validate and convert articles        
                        processed_articles = None
                        if recommended_articles:
                            try:
                                validated_articles = []
                                for article in recommended_articles:
                                    # Check if article has minimum required fields
                                    if isinstance(article, dict) and 'title' in article:
                                        # Ensure author is properly formatted
                                        author_obj = article.get("author", {})
                                        if not isinstance(author_obj, dict):
                                            author_obj = {"name": str(author_obj), "avatarUrl": None}
                                        
                                        # Ensure meta is properly formatted
                                        meta_obj = article.get("meta", {})
                                        if not isinstance(meta_obj, dict):
                                            meta_obj = {"readTime": 5, "views": 0, "likes": 0, "bookmarks": 0}
                                        
                                        article_obj = {
                                            "article_id": article.get("article_id", 0),
                                            "title": article.get("title", "Unknown"),
                                            "category": article.get("category", "Unknown"),
                                            "author": author_obj,
                                            "summary": article.get("summary", "No summary"),
                                            "pdf_url": article.get("pdf_url", ""),
                                            "tags": article.get("tags", []),
                                            "created_at": article.get("created_at", ""),
                                            "updated_at": article.get("updated_at", None),
                                            "cover_image_url": article.get("cover_image_url", None),
                                            "meta": meta_obj
                                        }
                                        validated_articles.append(article_obj)
                                processed_articles = validated_articles
                            except Exception as e:
                                logger.error(f"Error validating articles: {e}", exc_info=True)
                                processed_articles = None
                        
                        
                        final_response = ChatResponse(
                            answer=last_message.content,
                            follow_up_question=follow_up_question,
                            recommended_books=processed_books,
                            recommended_articles=processed_articles
                        )
                    except Exception as e:
                        logger.error(f"Error processing AI message: {e}", exc_info=True)
                        final_response = ChatResponse(
                            answer=last_message.content,
                            follow_up_question="Would you like to explore other topics in our library?",
                            recommended_books=None,
                            recommended_articles=None
                        )
        except Exception as e:
            logger.error(f"Error in chat processing: {e}", exc_info=True)

        # Fallback response if something went wrong
        if not final_response:
            final_response = ChatResponse(
                answer="I apologize, but I couldn't find relevant information in our library database. How else can I assist you with your library needs?",
                follow_up_question="Would you like to browse our featured books instead?",
                recommended_books=None,
                recommended_articles=None
            )

        # Return the response as JSON
        try:
            return final_response.model_dump_json(indent=2)
        except Exception as e:
            logger.error(f"Error serializing response: {e}", exc_info=True)
            # Ultimate fallback
            return '{"answer": "Sorry, an error occurred while processing your request.", "follow_up_question": "Can I help with something else?", "recommended_books": null, "recommended_articles": null}'
    
    
    
    
    
    
    
    