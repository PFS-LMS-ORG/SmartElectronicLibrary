import { useParams, useNavigate } from "react-router-dom";
import { useEffect, useState } from "react";
import axios from "axios";
import { useAuth } from "../context/AuthContext";
import { Star, Clock, Users, Book, ChevronLeft } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { toast } from "react-toastify"; // Add react-toastify for notifications

interface Book {
  id: number;
  title: string;
  cover_url: string;
  description: string;
  rating: number;
  summary: string;
  authors: string[];
  categories: string[];
  borrow_count: number;
  total_books: number;
  available_books: number;
}

interface RentalRequest {
  id: number;
  book_id: number;
  status: "pending" | "approved" | "rejected";
}

const BookDetails = () => {
  const { id } = useParams<{ id: string }>();
  const [book, setBook] = useState<Book | null>(null);
  const [relatedBooks, setRelatedBooks] = useState<Book[]>([]);
  const [loading, setLoading] = useState(true);
  const [relatedLoading, setRelatedLoading] = useState(true);
  const [activeTab, setActiveTab] = useState("overview");
  const [userRequest, setUserRequest] = useState<RentalRequest | null>(null); // Track user's request
  const [borrowLoading, setBorrowLoading] = useState(false); // Track borrow action
  const { isAuthenticated, isLoading: isAuthLoading, logout, user } = useAuth();
  const navigate = useNavigate();

  useEffect(() => {
    if (isAuthLoading) return;

    if (!isAuthenticated) {
      console.log("User not authenticated, redirecting to login");
      navigate("/login");
      return;
    }

    const fetchBookAndRequest = async () => {
      setLoading(true);
      try {
        const token = localStorage.getItem("token");
        if (!token) {
          throw new Error("No token found");
        }

        // Fetch book details
        console.log("Fetching book with token:", token.slice(0, 20) + "...");
        const bookResponse = await axios.get(`/api/books/${id}`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        console.log("Book response:", bookResponse.data);
        setBook(bookResponse.data);

        // Fetch user's rental request for this book
        const requestResponse = await axios.get(`/api/rental_requests/my_requests?page=1&per_page=10`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        const requests: RentalRequest[] = requestResponse.data.requests;
        const existingRequest = requests.find(
          (req: RentalRequest) => req.book_id === Number(id) && req.status !== "rejected"
        );
        setUserRequest(existingRequest || null);

        // Fetch related books
        fetchRelatedBooks(bookResponse.data.categories, bookResponse.data.id);
      } catch (error: any) {
        console.error("Error fetching data:", error.response?.data || error.message);
        if (error.response?.status === 401) {
          console.log("Unauthorized: Logging out and redirecting to login");
          logout();
          localStorage.removeItem("token");
          navigate("/login");
        }
      } finally {
        setLoading(false);
      }
    };

    fetchBookAndRequest();
  }, [id, isAuthenticated, isAuthLoading, logout, navigate]);

  const fetchRelatedBooks = async (categories: string[], bookId: number) => {
    setRelatedLoading(true);
    try {
      const token = localStorage.getItem("token");
      if (!token) {
        throw new Error("No token found");
      }

      const categoryParams = categories.map((c) => `category=${encodeURIComponent(c)}`).join("&");
      const response = await axios.get(`/api/books/related?${categoryParams}&exclude=${bookId}&limit=4`, {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("Related books response:", response.data);
      setRelatedBooks(response.data);
    } catch (error: any) {
      console.error("Error fetching related books:", error.response?.data || error.message);
    } finally {
      setRelatedLoading(false);
    }
  };

  const handleBorrow = async () => {
    if (!book || borrowLoading) return;

    setBorrowLoading(true);
    try {
      const token = localStorage.getItem("token");
      if (!token) {
        throw new Error("No token found");
      }

      const response = await axios.post(
        "/api/rental_requests",
        { book_id: book.id },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      console.log("Rental request response:", response.data);

      // Update userRequest state
      setUserRequest({ id: response.data.id, book_id: book.id, status: "pending" });

      // Optional: Update available_books (if backend doesn't auto-update)
      // setBook((prev) =>
      //   prev ? { ...prev, available_books: prev.available_books - 1 } : prev
      // );

      toast.success("Rental request created successfully! Awaiting admin approval.");
    } catch (error: any) {
      console.error("Error creating rental request:", error.response?.data || error.message);
      const errorMsg = error.response?.data?.error || "Failed to create rental request.";
      toast.error(errorMsg);
      if (error.response?.status === 401) {
        logout();
        localStorage.removeItem("token");
        navigate("/login");
      }
    } finally {
      setBorrowLoading(false);
    }
  };

  // function to unblock the button
  const handleUnblockButton = () => {
    setBorrowLoading(true);
  };

  const handleGoBack = () => {
    navigate(-1);
  };

  const navigateToBook = (bookId: number) => {
    navigate(`/book/${bookId}`);
  };

  // Loading state with animated skeleton
  if (loading || isAuthLoading) return (
    <div className="min-h-screen bg-gray-900 text-white">
      <div className="container mx-auto px-6 py-12">
        <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
          <div className="lg:col-span-4 flex justify-center">
            <div className="w-64 h-96 bg-gray-800 rounded-lg animate-pulse"></div>
          </div>
          <div className="lg:col-span-8">
            <div className="h-12 bg-gray-800 rounded-lg animate-pulse mb-4 w-3/4"></div>
            <div className="h-6 bg-gray-800 rounded-lg animate-pulse mb-8 w-1/2"></div>
            <div className="h-32 bg-gray-800 rounded-lg animate-pulse mb-6"></div>
            <div className="h-24 bg-gray-800 rounded-lg animate-pulse mb-6"></div>
            <div className="h-12 bg-gray-800 rounded-lg animate-pulse w-40"></div>
          </div>
        </div>
      </div>
    </div>
  );

  if (!book) return (
    <div className="min-h-screen bg-gray-900 text-white">
      <div className="container mx-auto px-6 py-12 flex flex-col items-center justify-center">
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          className="text-center"
        >
          <Book className="w-20 h-20 text-gray-600 mx-auto mb-6" />
          <h1 className="text-3xl font-bold mb-4">Book Not Found</h1>
          <p className="text-gray-400 mb-8">The book you're looking for doesn't exist or has been removed.</p>
          <button
            onClick={handleGoBack}
            className="px-6 py-3 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-white font-medium transition-colors duration-300"
          >
            Go Back
          </button>
        </motion.div>
      </div>
    </div>
  );

  // Book gradient colors based on categories
  const gradientColors = {
    "Fiction": "from-blue-600 to-purple-600",
    "Non-Fiction": "from-emerald-600 to-teal-600",
    "Mystery": "from-purple-600 to-pink-600",
    "Science Fiction": "from-cyan-600 to-blue-600",
    "Romance": "from-pink-600 to-red-600",
    "Biography": "from-amber-600 to-orange-600",
    "History": "from-lime-600 to-emerald-600",
    "default": "from-indigo-600 to-purple-600"
  };

  const getGradient = () => {
    if (!book.categories.length) return gradientColors.default;
    const category = book.categories[0];
    return gradientColors[category as keyof typeof gradientColors] || gradientColors.default;
  };

  const tabVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0, transition: { duration: 0.5 } },
  };

  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      className="min-h-screen bg-gray-900 text-white"
    >
      {/* Top color gradient bar */}
      <div className={`h-2 w-full bg-gradient-to-r ${getGradient()}`}></div>

      <div className="container mx-auto px-4 sm:px-6 py-8">
        {/* Back Button */}
        <motion.button
          whileHover={{ x: -5 }}
          onClick={handleGoBack}
          className="flex items-center text-gray-400 hover:text-white mb-8 transition-colors duration-300"
        >
          <ChevronLeft className="w-5 h-5 mr-2" />
          Back to Books
        </motion.button>

        {/* Main Grid Layout */}
        <div className="grid grid-cols-1 lg:grid-cols-12 gap-12">
          {/* Left Column - Book Cover */}
          <motion.div
            className="lg:col-span-4 flex flex-col items-center"
            initial={{ opacity: 0, y: 30 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.6 }}
          >
            {/* Book Cover with Hover Effect */}
            <motion.div
              className="relative mb-6 group"
              whileHover={{ scale: 1.03 }}
              transition={{ duration: 0.3, ease: "easeOut" }}
            >
              <img
                src={book.cover_url}
                alt={book.title}
                className="w-80 h-auto rounded-xl shadow-2xl object-cover z-10 relative"
              />
              {/* Backdrop glow effect */}
              <div
                className={`absolute -inset-2 bg-gradient-to-r ${getGradient()} rounded-xl blur-lg opacity-0 group-hover:opacity-30 transition-opacity duration-500 z-0`}
              ></div>
            </motion.div>

            {/* Book Stats */}
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 0.3, duration: 0.6 }}
              className="w-full max-w-sm bg-gray-800/50 backdrop-blur-md rounded-lg p-4 border border-gray-700/30 grid grid-cols-3 gap-2 text-center"
            >
              <div className="flex flex-col items-center">
                <div className="bg-gray-700/50 rounded-full w-10 h-10 flex items-center justify-center mb-2">
                  <Star className="w-5 h-5 text-yellow-400" />
                </div>
                <span className="text-lg font-bold">{book.rating.toFixed(1)}</span>
                <span className="text-xs text-gray-400">Rating</span>
              </div>
              <div className="flex flex-col items-center">
                <div className="bg-gray-700/50 rounded-full w-10 h-10 flex items-center justify-center mb-2">
                  <Clock className="w-5 h-5 text-green-400" />
                </div>
                <span className="text-lg font-bold">{book.available_books}</span>
                <span className="text-xs text-gray-400">Available</span>
              </div>
              <div className="flex flex-col items-center">
                <div className="bg-gray-700/50 rounded-full w-10 h-10 flex items-center justify-center mb-2">
                  <Users className="w-5 h-5 text-blue-400" />
                </div>
                <span className="text-lg font-bold">{book.borrow_count}</span>
                <span className="text-xs text-gray-400">Borrowed</span>
              </div>
            </motion.div>

            {/* Borrow Button */}
            <motion.button
              className={`mt-6 w-full max-w-sm py-4 px-6 rounded-lg font-medium text-lg relative overflow-hidden group ${
                book.available_books === 0 || userRequest || borrowLoading
                  ? "bg-gray-600 cursor-not-allowed"
                  : ""
              }`}
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 0.4, duration: 0.6 }}
              onClick={handleBorrow}
              whileHover={{ scale: book.available_books === 0 || userRequest || borrowLoading ? 1 : 1.02 }}
              whileTap={{ scale: book.available_books === 0 || userRequest || borrowLoading ? 1 : 0.98 }}
              disabled={book.available_books === 0 || !!userRequest || borrowLoading}
            >
              {/* Button background with gradient */}
              <div
                className={`absolute inset-0 bg-gradient-to-r ${
                  book.available_books === 0 || userRequest || borrowLoading ? "bg-gray-600" : getGradient()
                } transition-transform duration-500`}
              ></div>

              {/* Button hover animation */}
              <div
                className={`absolute inset-0 opacity-0 ${
                  book.available_books === 0 || userRequest || borrowLoading ? "" : "group-hover:opacity-30"
                } bg-white transition-opacity duration-500`}
              ></div>

              {/* Button text */}
              <span className="relative z-10">
                {borrowLoading
                  ? "Requesting..."
                  : userRequest
                  ? userRequest.status === "pending"
                    ? "Request Pending"
                    : "Book Borrowed"
                  : book.available_books === 0
                  ? "Not Available"
                  : "Borrow Now"}
              </span>
            </motion.button>
          </motion.div>

          {/* Right Column - Book Details */}
          <motion.div
            className="lg:col-span-8"
            initial={{ opacity: 0, y: 30 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.6, delay: 0.2 }}
          >
            {/* Title and Authors */}
            <h1 className="text-4xl sm:text-5xl font-extrabold mb-4 leading-tight">
              {book.title}
            </h1>
            {/* Authors in stylish boxes */}
            <div className="flex flex-wrap gap-2 mb-6">
              {book.authors.map((author, index) => (
                <motion.div
                  key={index}
                  initial={{ opacity: 0, scale: 0.9 }}
                  animate={{ opacity: 1, scale: 1 }}
                  transition={{ delay: 0.2 + index * 0.1, duration: 0.5 }}
                  whileHover={{ scale: 1.05, y: -3 }}
                  className={`px-4 py-2 rounded-lg bg-gradient-to-br ${getGradient()} bg-opacity-20 backdrop-blur-md border border-gray-700/30`}
                >
                  <span className="font-medium text-white">{author}</span>
                </motion.div>
              ))}
            </div>
            {/* Categories */}
            <div className="mb-8">
              <div className="flex flex-wrap gap-2 mt-2">
                {book.categories.map((category, index) => (
                  <motion.span
                    key={index}
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: 0.3 + index * 0.1, duration: 0.5 }}
                    whileHover={{ y: -2 }}
                    className="px-3 py-1 bg-gray-800/60 text-gray-200 text-xs rounded-full border border-gray-700/40 hover:border-gray-600 transition-colors duration-300"
                  >
                    {category}
                  </motion.span>
                ))}
              </div>
            </div>
            {/* Tab Navigation */}
            <div className="border-b border-gray-700/50 mb-6">
              <div className="flex space-x-6">
                {["overview", "summary", "details"].map((tab) => (
                  <button
                    key={tab}
                    className={`pb-3 px-2 relative ${
                      activeTab === tab ? "text-white font-medium" : "text-gray-400 hover:text-gray-200"
                    } transition-colors duration-300 capitalize`}
                    onClick={() => setActiveTab(tab)}
                  >
                    {tab}
                    {activeTab === tab && (
                      <motion.div
                        layoutId="activeTab"
                        className={`absolute bottom-0 left-0 right-0 h-0.5 bg-gradient-to-r ${getGradient()}`}
                      ></motion.div>
                    )}
                  </button>
                ))}
              </div>
            </div>
            {/* Tab Content */}
            <div className="min-h-56">
              <AnimatePresence mode="wait">
                {activeTab === "overview" && (
                  <motion.div
                    key="overview"
                    variants={tabVariants}
                    initial="hidden"
                    animate="visible"
                    exit="hidden"
                    className="prose prose-invert max-w-none"
                  >
                    <p className="text-gray-200 leading-relaxed font-light text-lg">
                      {book.description}
                    </p>
                  </motion.div>
                )}
                {activeTab === "summary" && (
                  <motion.div
                    key="summary"
                    variants={tabVariants}
                    initial="hidden"
                    animate="visible"
                    exit="hidden"
                  >
                    <div className="p-6 bg-gray-800/40 rounded-xl backdrop-blur-sm border border-gray-700/30">
                      <h3 className="text-xl font-semibold mb-4 text-gray-100">Summary</h3>
                      <p className="text-gray-300 leading-relaxed">
                        {book.summary || "No summary available for this book."}
                      </p>
                    </div>
                  </motion.div>
                )}
                {activeTab === "details" && (
                  <motion.div
                    key="details"
                    variants={tabVariants}
                    initial="hidden"
                    animate="visible"
                    exit="hidden"
                  >
                    <div className="p-6 bg-gray-800/40 rounded-xl backdrop-blur-sm border border-gray-700/30">
                      <h3 className="text-lg font-medium mb-4">Book Information</h3>
                      <ul className="space-y-3">
                        <li className="flex justify-between">
                          <span className="text-gray-400">ID:</span>
                          <span>{book.id}</span>
                        </li>
                        <li className="flex justify-between">
                          <span className="text-gray-400">Total Books:</span>
                          <span>{book.total_books}</span>
                        </li>
                        <li className="flex justify-between">
                          <span className="text-gray-400">Available:</span>
                          <span>{book.available_books}</span>
                        </li>
                        <li className="flex justify-between">
                          <span className="text-gray-400">Borrow Count:</span>
                          <span>{book.borrow_count}</span>
                        </li>
                      </ul>
                    </div>
                  </motion.div>
                )}
              </AnimatePresence>
            </div>

            {/* Similar Books Section */}
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.6, duration: 0.6 }}
              className="mt-12"
            >
              <h3 className="text-xl font-medium mb-6">You might also like</h3>
              {relatedLoading ? (
                <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
                  {[1, 2, 3, 4].map((i) => (
                    <div key={i} className="bg-gray-800/40 rounded-lg overflow-hidden animate-pulse">
                      <div className="h-36 bg-gray-700"></div>
                      <div className="p-3">
                        <div className="h-4 w-3/4 bg-gray-700 rounded mb-2"></div>
                        <div className="h-3 w-1/2 bg-gray-700 rounded"></div>
                      </div>
                    </div>
                  ))}
                </div>
              ) : relatedBooks.length > 0 ? (
                <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
                  {relatedBooks.map((relatedBook) => (
                    <motion.div
                      key={relatedBook.id}
                      whileHover={{ y: -5 }}
                      className="bg-gray-800/40 rounded-lg overflow-hidden cursor-pointer"
                      onClick={() => navigateToBook(relatedBook.id)}
                    >
                      <div className="h-48 bg-gray-700 relative">
                        <img
                          src={relatedBook.cover_url}
                          alt={relatedBook.title}
                          className="w-full h-full object-cover absolute inset-0"
                        />
                      </div>
                      <div className="p-3">
                        <h4 className="font-medium text-sm line-clamp-1">{relatedBook.title}</h4>
                        <p className="text-xs text-gray-400 mt-1 line-clamp-1">
                          {relatedBook.authors.join(", ")}
                        </p>
                      </div>
                    </motion.div>
                  ))}
                </div>
              ) : (
                <div className="bg-gray-800/40 rounded-lg p-6 text-center">
                  <p className="text-gray-400">No related books found.</p>
                </div>
              )}
            </motion.div>
          </motion.div>
        </div>
      </div>
    </motion.div>
  );
};

export default BookDetails;

from app.model import Rental, Book, User
from app.db import db
from datetime import datetime
from sqlalchemy.exc import IntegrityError
from sqlalchemy import or_

class RentalService:
    @staticmethod
    def create_rental(user_id, book_id, update_book=False):
        """
        Creates a new rental for a user and book.
        """
        user = User.query.get(user_id)
        if not user:
            raise ValueError("User not found")

        book = Book.query.get(book_id)
        if not book:
            raise ValueError("Book not found")
        if book.available_books <= 0:
            raise ValueError("No copies available for this book")

        existing_rental = Rental.query.filter_by(
            user_id=user_id, book_id=book_id, returned_at=None
        ).first()
        if existing_rental:
            raise ValueError("User already has an active rental for this book")

        rental = Rental(user_id=user_id, book_id=book_id)
        db.session.add(rental)

        if update_book:
            book.available_books -= 1
            book.borrow_count += 1

        try:
            db.session.commit()
            return rental
        except IntegrityError:
            db.session.rollback()
            raise ValueError("Failed to create rental")

    @staticmethod
    def return_book(rental_id):
        """
        Marks a rental as returned and updates book availability.
        """
        rental = Rental.query.get(rental_id)
        if not rental:
            raise ValueError("Rental not found")
        if rental.returned_at:
            raise ValueError("Rental already returned")

        book = Book.query.get(rental.book_id)
        if not book:
            raise ValueError("Book not found")

        try:
            rental.returned_at = datetime.utcnow()
            book.available_books += 1
            db.session.commit()
            return rental
        except IntegrityError:
            db.session.rollback()
            raise ValueError("Failed to return rental")

    @staticmethod
    def update_rental(rental_id, data):
        """
        Updates a rental's details.
        """
        rental = Rental.query.get(rental_id)
        if not rental:
            raise ValueError("Rental not found")

        user_id = data.get('user_id')
        book_id = data.get('book_id')
        rented_at = data.get('rented_at')
        returned_at = data.get('returned_at')

        old_book_id = rental.book_id
        was_returned = rental.returned_at is not None

        try:
            if user_id:
                user = User.query.get(user_id)
                if not user:
                    raise ValueError("User not found")
                rental.user_id = user_id

            if book_id and book_id != old_book_id:
                book = Book.query.get(book_id)
                if not book:
                    raise ValueError("Book not found")
                if book.available_books <= 0 and not was_returned:
                    raise ValueError("No copies available for this book")
                rental.book_id = book_id
                # Update old and new book counts
                old_book = Book.query.get(old_book_id)
                if old_book and not was_returned:
                    old_book.available_books += 1
                if book and not was_returned:
                    book.available_books -= 1
                    book.borrow_count += 1

            if rented_at:
                try:
                    rental.rented_at = datetime.fromisoformat(rented_at.replace('Z', '+00:00'))
                except ValueError:
                    raise ValueError("Invalid rented_at format")

            if 'returned_at' in data:
                if returned_at:
                    try:
                        rental.returned_at = datetime.fromisoformat(returned_at.replace('Z', '+00:00'))
                    except ValueError:
                        raise ValueError("Invalid returned_at format")
                else:
                    if not was_returned:
                        book = Book.query.get(rental.book_id)
                        if book:
                            book.available_books += 1
                    rental.returned_at = None

            db.session.commit()
            return rental
        except IntegrityError:
            db.session.rollback()
            raise ValueError("Failed to update rental")

    @staticmethod
    def delete_rental(rental_id):
        """
        Deletes a rental and updates book availability if active.
        """
        rental = Rental.query.get(rental_id)
        if not rental:
            raise ValueError("Rental not found")

        book = Book.query.get(rental.book_id)
        try:
            if not rental.returned_at and book:
                book.available_books += 1
            db.session.delete(rental)
            db.session.commit()
            return {"message": "Rental deleted successfully"}
        except IntegrityError:
            db.session.rollback()
            raise ValueError("Failed to delete rental")

    @staticmethod
    def bulk_delete_rentals(rental_ids):
        """
        Deletes multiple rentals and updates book availability.
        """
        if not rental_ids:
            raise ValueError("No rental IDs provided")

        try:
            for rental_id in rental_ids:
                rental = Rental.query.get(rental_id)
                if rental:
                    book = Book.query.get(rental.book_id)
                    if not rental.returned_at and book:
                        book.available_books += 1
                    db.session.delete(rental)
            db.session.commit()
            return {"message": f"Deleted {len(rental_ids)} rentals"}
        except IntegrityError:
            db.session.rollback()
            raise ValueError("Failed to delete rentals")

    @staticmethod
    def get_rental_by_id(rental_id):
        """
        Fetches a rental by its ID.
        """
        rental = Rental.query.get(rental_id)
        if not rental:
            raise ValueError("Rental not found")
        return rental
    
    @staticmethod
    def get_user_book_rental(user_id,book_id):
        """
        Fetches the latest rental for a specific user and book.
        """
        user = User.query.get(user_id)
        if not user:
            raise ValueError("User not found")
        book = Book.query.get(book_id)
        if not book:
            raise ValueError("Book not found")
        rental = Rental.query.filter_by(user_id=user_id, book_id=book_id).order_by(Rental.rented_at.desc()).first()
        return rental

    @staticmethod
    def get_user_rentals(user_id):
        """
        Fetches all rentals for a specific user.
        """
        user = User.query.get(user_id)
        if not user:
            raise ValueError("User not found")
        rentals = Rental.query.filter_by(user_id=user_id).all()
        return rentals

    @staticmethod
    def get_book_rentals(book_id):
        """
        Fetches all rentals for a specific book.
        """
        book = Book.query.get(book_id)
        if not book:
            raise ValueError("Book not found")
        rentals = Rental.query.filter_by(book_id=book_id).all()
        return rentals

    @staticmethod
    def get_all_rentals(page=1, per_page=10, status=None, search=None):
        """
        Fetches all rentals with pagination, status filter, and search.
        """
        query = Rental.query.join(User).join(Book)

        if status == 'active':
            query = query.filter(Rental.returned_at.is_(None))
        elif status == 'returned':
            query = query.filter(Rental.returned_at.isnot(None))

        if search:
            search_term = f'%{search}%'
            query = query.filter(
                or_(
                    User.name.ilike(search_term),
                    User.email.ilike(search_term),
                    Book.title.ilike(search_term)
                )
            )

        total_count = query.count()
        rentals = query.paginate(page=page, per_page=per_page, error_out=False).items
        return {
            "rentals": [rental.to_dict() for rental in rentals],
            "total_count": total_count,
            "total_pages": (total_count + per_page - 1) // per_page,
        }

    @staticmethod
    def get_active_rentals():
        """
        Fetches all active (unreturned) rentals.
        """
        rentals = Rental.query.filter(Rental.returned_at.is_(None)).all()
        return [rental.to_dict() for rental in rentals]

from app.model import RentalRequest, User, Book, Rental
from app.db import db
from app.services.RentalService import RentalService
from sqlalchemy.exc import IntegrityError
from sqlalchemy import or_
from datetime import datetime
from math import ceil

class RentalRequestService:
    @staticmethod
    def create_request(user_id, book_id):
        """
        Creates a new rental request for a book by a user.
        
        Args:
            user_id (int): ID of the user making the request
            book_id (int): ID of the book being requested
        
        Returns:
            dict: The created rental request as a dictionary
        
        Raises:
            ValueError: If the user or book is not found, book is unavailable, or request already exists
        """
        # Validate book
        book = Book.query.get(book_id)
        if not book:
            raise ValueError("Book not found")
        if book.available_books <= 0:
            raise ValueError("No copies available for this book")

        # Validate user
        user = User.query.get(user_id)
        if not user:
            raise ValueError("User not found")

        # Check for existing pending request
        existing_request = RentalRequest.query.filter_by(
            user_id=user_id, book_id=book_id, status="pending"
        ).first()
        if existing_request:
            raise ValueError("You already have a pending request for this book")

        # Create new request
        request = RentalRequest(user_id=user_id, book_id=book_id)
        db.session.add(request)
        try:
            db.session.commit()
            return request.to_dict()
        except IntegrityError:
            db.session.rollback()
            raise ValueError("Failed to create rental request")

    @staticmethod
    def get_pending_requests():
        """
        Fetches all pending rental requests.
        
        Returns:
            list: List of pending rental requests as dictionaries
        """
        requests = RentalRequest.query.filter_by(status="pending").all()
        return [req.to_dict() for req in requests]

    @staticmethod
    def get_all_requests(page=1, per_page=10, status='all', search=''):
        """
        Fetches all rental requests with pagination and filtering.
        
        Args:
            page (int): Page number
            per_page (int): Number of items per page
            status (str): Filter by status ('all', 'pending', 'approved', 'rejected')
            search (str): Search term to filter by user name, email, or book title
        
        Returns:
            dict: Contains rental_requests, total_count, and total_pages
        """
        try:
            # Base query
            query = RentalRequest.query

            # Apply status filter
            if status != 'all':
                query = query.filter(RentalRequest.status == status)

            # Apply search filter
            if search:
                search_term = f'%{search}%'
                query = query.join(RentalRequest.user).join(RentalRequest.book).filter(
                    or_(
                        RentalRequest.user.has(User.name.ilike(search_term)),
                        RentalRequest.user.has(User.email.ilike(search_term)),
                        RentalRequest.book.has(Book.title.ilike(search_term))
                    )
                )

            # Get total count for pagination
            total_count = query.count()

            # Calculate total pages
            total_pages = max(1, ceil(total_count / per_page))

            # Apply pagination
            requests = query.order_by(RentalRequest.requested_at.desc())\
                           .offset((page - 1) * per_page)\
                           .limit(per_page)\
                           .all()

            # Return response
            return {
                'requests': [req.to_dict() for req in requests],
                'total_count': total_count,
                'total_pages': total_pages
            }

        except Exception as e:
            raise ValueError(f"Failed to fetch rental requests: {str(e)}")

    @staticmethod
    def get_user_requests(user_id, page=1, per_page=10):
        """
        Fetches rental requests for a specific user with pagination.
        
        Args:
            user_id (int): ID of the user
            page (int): Page number
            per_page (int): Number of items per page
        
        Returns:
            dict: Contains requests, total_count, and total_pages
        """
        query = RentalRequest.query.filter_by(user_id=user_id)
        total_count = query.count()
        requests = query.order_by(RentalRequest.requested_at.desc())\
                       .offset((page - 1) * per_page)\
                       .limit(per_page)\
                       .all()
        return {
            "requests": [req.to_dict() for req in requests],
            "total_count": total_count,
            "total_pages": max(1, ceil(total_count / per_page))
        }

    @staticmethod
    def get_request_by_id(request_id):
        """
        Fetches a rental request by ID.
        
        Args:
            request_id (int): ID of the rental request
        
        Returns:
            dict: The rental request as a dictionary
        
        Raises:
            ValueError: If the request is not found
        """
        request = RentalRequest.query.get(request_id)
        if not request:
            raise ValueError("Rental request not found")
        return request.to_dict()

    @staticmethod
    def approve_request(request_id):
        """
        Approves a rental request, creates a rental, and updates book availability.
        
        Args:
            request_id (int): ID of the rental request
        
        Returns:
            dict: The updated rental request as a dictionary
        
        Raises:
            ValueError: If the request, book, or approval fails
        """
        request = RentalRequest.query.get(request_id)
        if not request:
            raise ValueError("Rental request not found")
        if request.status != "pending":
            raise ValueError("Request is not pending")

        book = Book.query.get(request.book_id)
        if not book:
            raise ValueError("Book not found")
        if book.available_books <= 0:
            raise ValueError("No copies available for this book")

        try:
            # Start transaction
            request.status = "approved"
            
            # Create rental using RentalService
            rental = RentalService.create_rental(request.user_id, request.book_id, update_book=True)
            
            # Update book availability
            # book.available_books -= 1
            # book.borrow_count += 1

            db.session.commit()
            return request.to_dict()
        except (IntegrityError, ValueError) as e:
            db.session.rollback()
            raise ValueError(f"Failed to approve request: {str(e)}")
        except Exception as e:
            db.session.rollback()
            raise ValueError("Internal server error")

    @staticmethod
    def reject_request(request_id):
        """
        Rejects a rental request.
        
        Args:
            request_id (int): ID of the rental request
        
        Returns:
            dict: The updated rental request as a dictionary
        
        Raises:
            ValueError: If the request is not found or not pending
        """
        request = RentalRequest.query.get(request_id)
        if not request:
            raise ValueError("Rental request not found")
        if request.status != "pending":
            raise ValueError("Request is not pending")

        try:
            request.status = "rejected"
            db.session.commit()
            return request.to_dict()
        except IntegrityError:
            db.session.rollback()
            raise ValueError("Failed to reject request")

    @staticmethod
    def cancel_request(request_id, user_id):
        """
        Cancels a user's own rental request.
        
        Args:
            request_id (int): ID of the rental request
            user_id (int): ID of the user attempting to cancel
        
        Returns:
            dict: Success message
        
        Raises:
            ValueError: If the request is not found, not owned by user, or not pending
        """
        request = RentalRequest.query.get(request_id)
        if not request:
            raise ValueError("Rental request not found")
        if request.user_id != user_id:
            raise ValueError("You can only cancel your own requests")
        if request.status != "pending":
            raise ValueError("Only pending requests can be canceled")

        try:
            db.session.delete(request)
            db.session.commit()
            return {"message": "Rental request canceled"}
        except IntegrityError:
            db.session.rollback()
            raise ValueError("Failed to cancel request")

    @staticmethod
    def get_all_requested_books():
        """
        Fetches all books with pending rental requests.
        
        Returns:
            list: List of books with pending requests as dictionaries
        """
        books = (
            db.session.query(Book)
            .join(RentalRequest)
            .filter(RentalRequest.status == "pending")
            .distinct()
            .all()
        )
        return [book.to_dict() for book in books]

from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.services.RentalService import RentalService
from app.model.User import User
from sqlalchemy.exc import IntegrityError

rental_controller = Blueprint('rental_controller', __name__)

def check_admin():
    """Helper to verify if the current user is an admin."""
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    if not user or user.role != 'admin':
        return jsonify({'error': 'Admin access required'}), 403
    return None

@rental_controller.route('/rentals', methods=['POST'])
@jwt_required()
def create_rental():
    """
    Create a new rental (admin only).
    Body: { "user_id": int, "book_id": int }
    """
    try:
        admin_check = check_admin()
        if admin_check:
            return admin_check

        data = request.get_json()
        if not data or 'user_id' not in data or 'book_id' not in data:
            return jsonify({'error': 'user_id and book_id are required'}), 400

        rental = RentalService.create_rental(data['user_id'], data['book_id'], update_book=True)
        return jsonify(rental.to_dict()), 201
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except IntegrityError:
        return jsonify({'error': 'Failed to create rental'}), 400
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500


@rental_controller.route('/rentals', methods=['GET'])
@jwt_required()
def get_all_rentals():
    """
    Get all rentals with pagination and filters (admin only).
    Query params:
        - page (default=1): Page number for pagination
        - per_page (default=10): Number of items per page
        - status (optional): Filter by rental status ('active', 'returned', 'all')
        - search (optional): Search term to filter by user name, email, or book title
    Returns:
        JSON response with rentals, total count, and total pages
    """
    try:
        # Check if user is admin
        admin_check = check_admin()
        if admin_check:
            return admin_check

        # Extract query parameters
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 10))
        status = request.args.get('status', 'all')  # Default to 'all' if not provided
        search = request.args.get('search', '').strip()  # Default to empty string if not provided

        # Validate status parameter
        valid_statuses = ['all', 'active', 'returned']
        if status not in valid_statuses:
            return jsonify({'error': f"Invalid status. Must be one of: {', '.join(valid_statuses)}"}), 400

        # Pass parameters to the service layer
        result = RentalService.get_all_rentals(page, per_page, status, search)
        return jsonify(result), 200

    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500


@rental_controller.route('/rentals/<int:rental_id>', methods=['GET'])
@jwt_required()
def get_rental(rental_id):
    """
    Get a specific rental by ID.
    """
    try:
        user_id = get_jwt_identity()
        rental = RentalService.get_rental_by_id(rental_id)
        
        # Allow access if user owns the rental or is admin
        user = User.query.get(user_id)
        if rental.user_id != user_id and user.role != 'admin':
            return jsonify({'error': 'Unauthorized access'}), 403
            
        return jsonify(rental.to_dict()), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 404
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@rental_controller.route('/rentals/<int:rental_id>', methods=['PUT'])
@jwt_required()
def update_rental(rental_id):
    """
    Update a rental's details (admin only).
    Body: { "user_id": int, "book_id": int, "rented_at": str, "returned_at": str|null }
    """
    try:
        admin_check = check_admin()
        if admin_check:
            return admin_check

        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400

        rental = RentalService.update_rental(rental_id, data)
        return jsonify(rental.to_dict()), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except IntegrityError:
        return jsonify({'error': 'Failed to update rental'}), 400
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@rental_controller.route('/rentals/<int:rental_id>', methods=['DELETE'])
@jwt_required()
def delete_rental(rental_id):
    """
    Delete a rental (admin only).
    """
    try:
        admin_check = check_admin()
        if admin_check:
            return admin_check

        result = RentalService.delete_rental(rental_id)
        return jsonify(result), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 404
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@rental_controller.route('/rentals/bulk', methods=['DELETE'])
@jwt_required()
def bulk_delete_rentals():
    """
    Delete multiple rentals (admin only).
    Body: { "rental_ids": [int] }
    """
    try:
        admin_check = check_admin()
        if admin_check:
            return admin_check

        data = request.get_json()
        if not data or 'rental_ids' not in data or not isinstance(data['rental_ids'], list):
            return jsonify({'error': 'rental_ids array is required'}), 400

        result = RentalService.bulk_delete_rentals(data['rental_ids'])
        return jsonify(result), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@rental_controller.route('/rentals/active', methods=['GET'])
@jwt_required()
def get_active_rentals():
    """
    Get all active (unreturned) rentals (admin only).
    """
    try:
        admin_check = check_admin()
        if admin_check:
            return admin_check
        
        rentals = RentalService.get_active_rentals()
        return jsonify({'rentals': rentals}), 200
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@rental_controller.route('/rentals/<int:rental_id>/return', methods=['PUT'])
@jwt_required()
def return_rental(rental_id):
    """
    Mark a rental as returned (admin only).
    """
    try:
        admin_check = check_admin()
        if admin_check:
            return admin_check
        
        rental = RentalService.return_book(rental_id)
        if not rental:
            return jsonify({'error': 'Rental not found'}), 404
        return jsonify(rental.to_dict()), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@rental_controller.route('/rentals/my_rentals', methods=['GET'])
@jwt_required()
def get_my_rentals():
    """
    Get the current user's rentals with pagination.
    Query params: page (default=1), per_page (default=10)
    """
    try:
        user_id = get_jwt_identity()
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 10))
        
        rentals = RentalService.get_user_rentals(user_id)
        # Paginate manually for simplicity
        total_count = len(rentals)
        start = (page - 1) * per_page
        end = start + per_page
        paginated_rentals = rentals[start:end]
        
        return jsonify({
            'rentals': [rental.to_dict() for rental in paginated_rentals],
            'total_count': total_count,
            'total_pages': (total_count + per_page - 1) // per_page,
        }), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500
    

@rental_controller.route('/rentals/specific_rental/<int:user_id>/<int:book_id>', methods=['GET'])
@jwt_required()
def get_specific_rental(user_id, book_id):
    """
    Get a specific rental by user_id and book_id.
    """
    try:
        user = User.query.get(user_id)
        if not user:
            return jsonify({'error': 'User not found'}), 404
        
        rental = RentalService.get_user_book_rental(user_id, book_id)
        if not rental:
            return jsonify({'error': 'Rental not found'}), 404
        
        return jsonify(rental.to_dict()), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500


from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.model.User import User
from app.services.RentalRequestService import RentalRequestService
from sqlalchemy.exc import SQLAlchemyError

rental_request_controller = Blueprint('rental_request_controller', __name__)

def check_admin():
    """Helper to verify if the current user is an admin."""
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    if not user or user.role != 'admin':
        return jsonify({'error': 'Admin access required'}), 403
    return None

@rental_request_controller.route('/rental_requests', methods=['POST'])
@jwt_required()
def create_rental_request():
    """
    Create a new rental request.
    Body: { "book_id": int }
    """
    try:
        data = request.get_json()
        if not data or 'book_id' not in data:
            return jsonify({'error': 'book_id is required'}), 400
        
        user_id = get_jwt_identity()
        rental_request = RentalRequestService.create_request(user_id, data['book_id'])
        return jsonify(rental_request), 201
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@rental_request_controller.route('/rental_requests/pending', methods=['GET'])
@jwt_required()
def get_pending_requests():
    """
    Get all pending rental requests (admin only).
    """
    try:
        admin_check = check_admin()
        if admin_check:
            return admin_check
        
        requests = RentalRequestService.get_pending_requests()
        return jsonify({'requests': requests}), 200
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@rental_request_controller.route('/rental_requests', methods=['GET'])
@jwt_required()
def get_all_requests():
    """
    Get all rental requests with pagination and filters (admin only).
    Query params:
        - page (default=1): Page number for pagination
        - per_page (default=10): Number of items per page
        - status (optional): Filter by request status ('pending', 'approved', 'rejected', 'all')
        - search (optional): Search term to filter by user name, email, or book title
    Returns:
        JSON response with rental requests, total count, and total pages
    """
    try:
        # Check if user is admin
        admin_check = check_admin()
        if admin_check:
            return admin_check

        # Extract query parameters
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 10))
        status = request.args.get('status', 'all')  # Default to 'all' if not provided
        search = request.args.get('search', '').strip()  # Default to empty string if not provided

        # Validate status parameter
        valid_statuses = ['all', 'pending', 'approved', 'rejected']
        if status not in valid_statuses:
            return jsonify({'error': f"Invalid status. Must be one of: {', '.join(valid_statuses)}"}), 400

        # Pass parameters to the service layer
        result = RentalRequestService.get_all_requests(page, per_page, status, search)
        return jsonify(result), 200

    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500
    

@rental_request_controller.route('/rental_requests/my_requests', methods=['GET'])
@jwt_required()
def get_my_requests():
    """
    Get the current user's rental requests with pagination.
    Query params: page (default=1), per_page (default=10)
    """
    try:
        user_id = get_jwt_identity()
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 10))
        
        result = RentalRequestService.get_user_requests(user_id, page, per_page)
        return jsonify(result), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@rental_request_controller.route('/rental_requests/<int:request_id>', methods=['GET'])
@jwt_required()
def get_rental_request(request_id):
    """
    Get a specific rental request by ID.
    """
    try:
        user_id = get_jwt_identity()
        request_data = RentalRequestService.get_request_by_id(request_id)
        
        # Allow access if user owns the request or is admin
        user = User.query.get(user_id)
        if request_data['user_id'] != user_id and user.role != 'admin':
            return jsonify({'error': 'Unauthorized access'}), 403
            
        return jsonify(request_data), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 404
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@rental_request_controller.route('/rental_requests/<int:request_id>/approve', methods=['PUT'])
@jwt_required()
def approve_rental_request(request_id):
    """
    Approve a rental request, create a rental, and update book (admin only).
    """
    try:
        admin_check = check_admin()
        if admin_check:
            return admin_check
        
        request_data = RentalRequestService.approve_request(request_id)
        return jsonify(request_data), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@rental_request_controller.route('/rental_requests/<int:request_id>/reject', methods=['PUT'])
@jwt_required()
def reject_rental_request(request_id):
    """
    Reject a rental request (admin only).
    """
    try:
        admin_check = check_admin()
        if admin_check:
            return admin_check
        
        request_data = RentalRequestService.reject_request(request_id)
        return jsonify(request_data), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@rental_request_controller.route('/rental_requests/<int:request_id>', methods=['DELETE'])
@jwt_required()
def cancel_rental_request(request_id):
    """
    Cancel a rental request (user's own request).
    """
    try:
        user_id = get_jwt_identity()
        result = RentalRequestService.cancel_request(request_id, user_id)
        return jsonify(result), 200
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@rental_request_controller.route('/rental_requests/requested_books', methods=['GET'])
@jwt_required()
def get_requested_books():
    """
    Get all books with pending rental requests (admin only).
    """
    try:
        admin_check = check_admin()
        if admin_check:
            return admin_check
        
        books = RentalRequestService.get_all_requested_books()
        return jsonify({'books': books}), 200
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

    